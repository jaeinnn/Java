package javaStudy;
import java.util.Scanner;

//배열

/*
배열(array)은 인덱스(Index)와 인덱스에 대응하는 데이터들로 이루어진
연속적인 자료구조로서, 같은 종류의 데이터들이 순차적으로 저장된다.
10개의 정수 값을 저장하고 합할 때, 서로 다른 변수의 이름을 10개나 만들어야 하면 
코드가 길고 지저분하다. 이런 방법으로 1000개의 정수를 합하는 경우에는 변수를
1000개나 사용하고, sum을 구하는 코드 역시 너무 길어서 작성이 불가능하다.

int i[] = new int[10]; //10개의 정수 공간 배열 생성. 배열의 이름은 i 
10개의 정수로 구성된 배열을 사용하면 위의 코드로 간단하게 작성할 수 있다.

배열을 사용하는 큰 이유 중 하나는 반복문의 활용에 있다.
배열을 사용하면 다음과 같이 for문으로 10개의 정수 합을 간단하게 구할 수 있다.

for(sum=0,n=0;n<10;n++)
    sum += i[n]; 
*/

/*

자바에서 배열의 생성은 두 단계로 이루어진다

  * 배열에 대한 레퍼런스 변수선언 (배열 선언문으로 레퍼런스 변수 intArray선언)
    int intArray[]; 
    int[] intArray; 
이 선언만으로 배열 공간이 할당되지 않으며, 레퍼런스 변수 intArray만 생성된다.
intArray는 배열 공간에 대한 주소값(레퍼런스값)을 가지며 그 자체가 배열은 아니다.
아직 정수를 저장할 배열 공간이 생성되지 않았으므로 intArray값은 null이다.

배열의 주소를 레퍼런스라고 부르며, 배열에 대한 주소 값을 가지는 변수를
레퍼런스 변수라고 부른다. 배열의 타입은 배열을 구성하는 원소의 타입이며,
배열의 레퍼런스변수는 다음 두가지 방법으로 선언할 수있다. 
   int intArray[]; 
   int[] intArray; 
    
  * 배열 생성 - 배열의 저장 공간 할당 
    intArray = new int[5]; 
 
*/


/*

배열 선언시 [] 안에 배열의 크기를 지정해서는 안 된다. 
int intArray[10]; 
배열의 크기를 지정할 수 없기 때문에 이런 문장은 컴파일 오류가 난다.

배열 생성은 데이터를 저장할 배열 공간을 할당받는 과정이다.
반드시 new 연산자를 이용하여 배열을 생성하며 []안에 생성할 원소 개수를 지정한다.

intArray = new int[5]; 
이 코드는 정수 5개의 배열 공간을 할당받고 이 배열에대한 레퍼런스 값(주소값)을 
intArray에 저장한다. 이제 intArray를 배열로 사용할 수 있다. 

int intArray[] = new int[5]; 
이렇게 배열의 선언과 생성을 동시에 할 수있다

 */

/*
배열 선언문에서 {}에 원소를 나열하면 초기화된 배열을 만들 수 있다.
배열을 초기화하는 예를 들면 다음과 같다

int intArray[] = {4,3,2,1,0};
double doubleArray[] = {0.01, 0.02, 0.03, 0.04}; 

intArray 배열의 크기는 자동으로 5가 되며,
doubleArray 배열의 크기는 자동으로 4가 된다.
생성되는 배열의 원소 개수는 {}에 나열된 값의 개수로 정해지므로
[]에 크기를 주어서는 안 된다.

*/


/*
//배열 인덱스와 배열 원소접근 
 
 배열의 index는 정수만 가능하다. 인덱스는 0부터시작하며 마지막 원소의
 인덱스는 (배열크기-1)이다. 배열의 원소는 인덱스를 이용하여 접근한다. 

int intArray[] = new int[5]; //원소가 5개인 배열 생성. 인덱스는 0~4까지 가능 
intArray[3] = 6; //원소 3에 6 저장
int n = intArray[3]; //원소 3의 값을 읽어 n에 저장. n은 6이된다. 

n = intArray[-2]; //실행 오류. 인덱스로 음수 사용 불가능.
n = intArray[5]; //실행오류. 5는 인덱스의 범위(0~4)를 넘었음. 


배열의 원소를 접근하려면 반드시 배열이 생성(공간 할당)되어 있어야 한다.
배열이 생성되어 있지 않는 상태에서 배열을 사용하면 
배열이 초기화되지 않았다는 컴파일 오류가 발생하거나 실행시간 오류가 발생한다.
다음은 생성하지 않은 배열을 잘못 사용한 사례이다.
int intArray []; //배열에 대한 레퍼런스만 선언
intArray[1] = 8; //오류. 생성되지 않은 배열 사용 

 */

/*
// 레퍼런스 치환과 배열 공유

자바에서는 레퍼런스 변수와 배열 공간이 분리되어 있기 때문에, 다수의 레퍼런스 변수가
하나의 배열공간을 가리키는 배열 공유가 쉽게 이루어진다.

int intArray[] = new int[5]; 
int myArray[] = intArray; //레퍼런스 치환. myArray는 intArray와 동일한 배열 참조 

앞의 코드에서 두번째 라인은 레퍼런스 변수 myArray를 생성하고 intArray변수의 
값을 myArray에 치환하는 코드이다. 이 치환으로 intArray 배열이 
복사되는것이 아니라, 레퍼런스 즉 배열에대한 주소만 복사된다. 
그 결과 myArray는 intArray와 동일한 레퍼런스 값을 가지게 되어 
myArray는 intArray의 배열을 공유하게되고, 
myArray로 intArray의 배열 원소를 마음대로 접근할 수 있다.

 */



//양수 5개를 입력받아 배열에 저장하고, 제일 큰 수를 출력하는 프로그램을 작성하라
public class Ex3_7 {
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in); 
		
		int intArray[] = new int[5]; //배열생성
		int max = 0; //현재가장 큰 수 
		System.out.println("양수 5개를 입력하세요.");
		for(int i=0; i<5; i++) {
			intArray[i] = scanner.nextInt(); //입력받은 정수를 배열에 저장
			if(intArray[i] > max) //intArray[i]가 현재 가장 큰 수보다 크면
				max = intArray[i]; //intArray[i]를 max로 변경		
		}
		System.out.print("가장 큰 수는 " + max + "입니다.");
		
		scanner.close();
		
	}

}